# 腾讯云CODING DevOps CI/CD配置
# 适用于Python FastAPI后端服务部署到腾讯云TKE

# 流水线配置
pipeline:
  name: "鉴宝后端服务CI/CD流水线"
  displayName: "jianbao-backend-pipeline"
  
# 触发条件
trigger:
  push:
    branches:
      - master
      - main
      - develop
    paths:
      - "**/*.py"
      - "requirements.txt"
      - "Dockerfile"
      - ".coding-ci.yml"
  mr:
    branches:
      - master
      - main
    paths:
      - "**/*.py"
      - "requirements.txt"
      - "Dockerfile"

# 环境变量
variables:
  # 腾讯云配置
  TCR_REGISTRY: "ccr.ccs.tencentyun.com"
  TCR_NAMESPACE: "jianbao"
  IMAGE_NAME: "backend"
  TKE_REGION: "ap-beijing"
  
  # 环境配置
  PROD_NAMESPACE: "jianbao-system"
  STAGING_NAMESPACE: "jianbao-staging"
  DEPLOYMENT_NAME: "jianbao-backend"
  
  # Python配置
  PYTHON_VERSION: "3.11"
  PIP_CACHE_DIR: "/root/.cache/pip"

# 阶段定义
stages:
  # =================================
  # 阶段1: 代码质量检查
  # =================================
  - stage: "代码检查"
    displayName: "Code Quality Check"
    jobs:
      - job: "代码质量检查"
        displayName: "Lint and Format Check"
        condition: always()
        steps:
          - name: "检出代码"
            uses: "git-checkout@1"
            
          - name: "设置Python环境"
            uses: "setup-python@1"
            with:
              python-version: ${{ variables.PYTHON_VERSION }}
              
          - name: "安装开发依赖"
            run: |
              python -m pip install --upgrade pip
              pip install black flake8 isort mypy pytest pytest-cov
              
          - name: "代码格式检查"
            run: |
              echo "🔍 检查代码格式..."
              black --check --diff . || {
                echo "❌ 代码格式不符合规范"
                echo "💡 请运行: black . 来自动格式化"
                exit 1
              }
              
              echo "🔍 检查导入排序..."
              isort --check-only --diff . || {
                echo "❌ 导入排序不符合规范" 
                echo "💡 请运行: isort . 来自动排序"
                exit 1
              }
              
          - name: "代码规范检查"
            run: |
              echo "🔍 执行Flake8检查..."
              # 严重错误必须修复
              flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
              # 其他问题作为警告
              flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
              
          - name: "类型检查"
            run: |
              echo "🔍 执行MyPy类型检查..."
              mypy . --ignore-missing-imports || echo "⚠️ 类型检查发现问题，请关注"
            condition: succeededOrFailed()

  # =================================
  # 阶段2: 自动化测试
  # =================================
  - stage: "自动化测试"
    displayName: "Automated Testing"
    dependsOn: "代码检查"
    jobs:
      - job: "单元测试"
        displayName: "Unit and Integration Tests"
        services:
          - mysql:
              image: "mysql:8.0"
              env:
                MYSQL_ROOT_PASSWORD: "testpass"
                MYSQL_DATABASE: "jianbao_test"
                MYSQL_USER: "jianbao"
                MYSQL_PASSWORD: "testpass"
              ports:
                - "3306:3306"
              
          - redis:
              image: "redis:7-alpine"
              ports:
                - "6379:6379"
        steps:
          - name: "检出代码"
            uses: "git-checkout@1"
            
          - name: "设置Python环境"
            uses: "setup-python@1"
            with:
              python-version: ${{ variables.PYTHON_VERSION }}
              
          - name: "安装系统依赖"
            run: |
              apt-get update
              apt-get install -y default-libmysqlclient-dev pkg-config gcc
              
          - name: "安装Python依赖"
            run: |
              python -m pip install --upgrade pip
              pip install -r requirements.txt
              pip install pytest pytest-cov pytest-asyncio coverage
              
          - name: "等待数据库就绪"
            run: |
              echo "⏳ 等待MySQL启动..."
              for i in {1..30}; do
                if mysqladmin ping -h mysql -P 3306 -u root -ptestpass --silent; then
                  echo "✅ MySQL已就绪"
                  break
                fi
                echo "⏳ 等待MySQL启动... ($i/30)"
                sleep 2
              done
              
              echo "⏳ 等待Redis启动..."
              for i in {1..30}; do
                if redis-cli -h redis -p 6379 ping | grep PONG; then
                  echo "✅ Redis已就绪"
                  break
                fi
                echo "⏳ 等待Redis启动... ($i/30)"
                sleep 2
              done
              
          - name: "运行测试"
            env:
              DATABASE_URL: "mysql+pymysql://jianbao:testpass@mysql:3306/jianbao_test"
              REDIS_URL: "redis://redis:6379/0"
              TESTING: "true"
            run: |
              echo "🧪 运行单元测试和集成测试..."
              
              # 创建测试报告目录
              mkdir -p test-results
              
              # 运行测试并生成覆盖率报告
              pytest tests/ -v \
                --cov=. \
                --cov-report=xml:test-results/coverage.xml \
                --cov-report=html:test-results/htmlcov \
                --cov-report=term \
                --junit-xml=test-results/pytest-report.xml
              
              echo "📊 测试覆盖率统计:"
              coverage report
              
          - name: "上传测试报告"
            uses: "upload-artifacts@1"
            with:
              name: "test-results"
              path: "test-results/"
            condition: always()

  # =================================
  # 阶段3: 安全扫描
  # =================================
  - stage: "安全扫描"
    displayName: "Security Scanning"
    dependsOn: "代码检查"
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: "安全扫描"
        displayName: "Dependency and Code Security Scan"
        steps:
          - name: "检出代码"
            uses: "git-checkout@1"
            
          - name: "设置Python环境"
            uses: "setup-python@1"
            with:
              python-version: ${{ variables.PYTHON_VERSION }}
              
          - name: "安装安全扫描工具"
            run: |
              pip install safety bandit
              
          - name: "依赖安全扫描"
            run: |
              echo "🔍 扫描依赖包安全漏洞..."
              safety check -r requirements.txt --json --output security-results/safety-report.json || {
                echo "⚠️ 发现依赖包安全问题，请检查报告"
              }
            condition: succeededOrFailed()
            
          - name: "代码安全扫描"
            run: |
              echo "🔍 扫描代码安全问题..."
              mkdir -p security-results
              bandit -r . -f json -o security-results/bandit-report.json || {
                echo "⚠️ 发现代码安全问题，请检查报告"
              }
            condition: succeededOrFailed()
            
          - name: "上传安全报告"
            uses: "upload-artifacts@1"
            with:
              name: "security-reports"
              path: "security-results/"
            condition: always()

  # =================================
  # 阶段4: 构建Docker镜像
  # =================================
  - stage: "构建镜像"
    displayName: "Build Docker Image"
    dependsOn:
      - "代码检查"
      - "自动化测试"
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: "构建推送镜像"
        displayName: "Build and Push Docker Image"
        steps:
          - name: "检出代码"
            uses: "git-checkout@1"
            
          - name: "设置Docker环境"
            uses: "setup-docker@1"
            
          - name: "生成镜像标签"
            run: |
              # 生成唯一的镜像标签
              TIMESTAMP=$(date +%Y%m%d-%H%M%S)
              SHORT_SHA=$(echo $CODING_BUILD_REF | cut -c1-8)
              IMAGE_TAG="${TIMESTAMP}-${SHORT_SHA}"
              
              echo "🏷️ 镜像标签: ${IMAGE_TAG}"
              echo "##[set-variable name=IMAGE_TAG]${IMAGE_TAG}"
              
              # 设置完整镜像名称
              FULL_IMAGE_NAME="${TCR_REGISTRY}/${TCR_NAMESPACE}/${IMAGE_NAME}:${IMAGE_TAG}"
              LATEST_IMAGE_NAME="${TCR_REGISTRY}/${TCR_NAMESPACE}/${IMAGE_NAME}:latest"
              
              echo "##[set-variable name=FULL_IMAGE_NAME]${FULL_IMAGE_NAME}"
              echo "##[set-variable name=LATEST_IMAGE_NAME]${LATEST_IMAGE_NAME}"
              
          - name: "登录腾讯云容器镜像仓库"
            uses: "tcr-login@1"
            with:
              region: ${{ variables.TKE_REGION }}
              
          - name: "构建Docker镜像"
            run: |
              echo "🔨 构建Docker镜像..."
              
              # 构建镜像
              docker build \
                --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                --build-arg VCS_REF=$CODING_BUILD_REF \
                --build-arg VERSION=$IMAGE_TAG \
                -t $FULL_IMAGE_NAME \
                -t $LATEST_IMAGE_NAME \
                -f Dockerfile .
              
              echo "✅ 镜像构建完成"
              
          - name: "推送镜像到TCR"
            run: |
              echo "📤 推送镜像到腾讯云容器镜像仓库..."
              
              # 推送带标签的镜像
              docker push $FULL_IMAGE_NAME
              echo "✅ 推送完成: $FULL_IMAGE_NAME"
              
              # 推送latest镜像
              docker push $LATEST_IMAGE_NAME
              echo "✅ 推送完成: $LATEST_IMAGE_NAME"
              
          - name: "镜像安全扫描"
            run: |
              echo "🔍 执行镜像安全扫描..."
              # 使用腾讯云内置的镜像安全扫描
              echo "镜像: $FULL_IMAGE_NAME"
              echo "📊 扫描结果将在TCR控制台查看"
            condition: succeededOrFailed()

  # =================================
  # 阶段5: 部署到测试环境
  # =================================
  - stage: "部署测试环境"
    displayName: "Deploy to Staging"
    dependsOn: "构建镜像"
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - job: "部署到测试环境"
        displayName: "Deploy to Staging Environment"
        steps:
          - name: "检出代码"
            uses: "git-checkout@1"
            
          - name: "配置TKE访问"
            uses: "tke-config@1"
            with:
              region: ${{ variables.TKE_REGION }}
              
          - name: "部署到测试环境"
            run: |
              echo "🚀 开始部署到测试环境..."
              
              # 创建测试命名空间
              kubectl create namespace $STAGING_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
              
              # 准备部署配置
              cp -r k8s staging-k8s
              cp -r infrastructure staging-infrastructure
              
              # 更新镜像标签和命名空间
              sed -i "s|${TCR_REGISTRY}/${TCR_NAMESPACE}/${IMAGE_NAME}:latest|${FULL_IMAGE_NAME}|g" staging-k8s/deployment.yaml
              sed -i "s|${PROD_NAMESPACE}|${STAGING_NAMESPACE}|g" staging-k8s/*.yaml
              sed -i "s|${PROD_NAMESPACE}|${STAGING_NAMESPACE}|g" staging-infrastructure/*.yaml
              
              # 部署密钥和配置
              kubectl apply -f staging-infrastructure/secrets.yaml -n $STAGING_NAMESPACE
              
              # 部署应用
              kubectl apply -f staging-k8s/ -n $STAGING_NAMESPACE
              
              # 等待部署完成
              echo "⏳ 等待部署完成..."
              kubectl rollout status deployment/$DEPLOYMENT_NAME -n $STAGING_NAMESPACE --timeout=300s
              
              # 显示部署状态
              echo "📊 部署状态:"
              kubectl get pods -n $STAGING_NAMESPACE -l app=jianbao-backend
              kubectl get svc -n $STAGING_NAMESPACE
              
              echo "✅ 测试环境部署完成！"
              echo "🌐 访问地址: https://api-staging.jianbao.com/health"

  # =================================
  # 阶段6: 部署到生产环境
  # =================================
  - stage: "部署生产环境"
    displayName: "Deploy to Production"
    dependsOn:
      - "构建镜像"
      - "安全扫描"
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))
    jobs:
      - job: "部署到生产环境"
        displayName: "Deploy to Production Environment"
        steps:
          - name: "检出代码"
            uses: "git-checkout@1"
            
          - name: "配置TKE访问"
            uses: "tke-config@1"
            with:
              region: ${{ variables.TKE_REGION }}
              
          - name: "生产环境部署"
            run: |
              echo "🚀 开始生产环境部署..."
              
              # 记录当前部署状态
              CURRENT_IMAGE=$(kubectl get deployment $DEPLOYMENT_NAME -n $PROD_NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "none")
              echo "📋 当前镜像: $CURRENT_IMAGE"
              echo "📋 新镜像: $FULL_IMAGE_NAME"
              
              # 蓝绿部署策略
              echo "🔄 执行滚动更新..."
              kubectl set image deployment/$DEPLOYMENT_NAME \
                backend=$FULL_IMAGE_NAME \
                -n $PROD_NAMESPACE
              
              # 等待滚动更新完成
              echo "⏳ 等待滚动更新完成..."
              kubectl rollout status deployment/$DEPLOYMENT_NAME -n $PROD_NAMESPACE --timeout=600s
              
              # 健康检查
              echo "🩺 执行健康检查..."
              sleep 30
              
              # 验证部署成功
              if kubectl exec -n $PROD_NAMESPACE deployment/$DEPLOYMENT_NAME -- curl -f http://localhost:8000/health --max-time 10; then
                echo "✅ 生产环境部署成功！"
                kubectl get pods -n $PROD_NAMESPACE -l app=jianbao-backend
                echo "🌐 服务地址: https://api.jianbao.com/health"
                echo "📚 API文档: https://api.jianbao.com/docs"
              else
                echo "❌ 健康检查失败，开始自动回滚..."
                kubectl rollout undo deployment/$DEPLOYMENT_NAME -n $PROD_NAMESPACE
                kubectl rollout status deployment/$DEPLOYMENT_NAME -n $PROD_NAMESPACE --timeout=300s
                echo "🔄 已回滚到上一个版本"
                exit 1
              fi

  # =================================
  # 阶段7: 部署通知
  # =================================
  - stage: "部署通知"
    displayName: "Deployment Notification"
    dependsOn:
      - "部署测试环境"
      - "部署生产环境"
    condition: always()
    jobs:
      - job: "发送通知"
        displayName: "Send Notification"
        steps:
          - name: "发送成功通知"
            run: |
              if [ "$CODING_BUILD_STATUS" = "success" ]; then
                echo "📢 发送部署成功通知..."
                
                # 确定部署环境
                if [ "$CODING_BUILD_REF" = "refs/heads/develop" ]; then
                  ENV_NAME="测试环境"
                  ENV_URL="https://api-staging.jianbao.com"
                elif [ "$CODING_BUILD_REF" = "refs/heads/main" ] || [ "$CODING_BUILD_REF" = "refs/heads/master" ]; then
                  ENV_NAME="生产环境"
                  ENV_URL="https://api.jianbao.com"
                else
                  ENV_NAME="未知环境"
                  ENV_URL="#"
                fi
                
                # 发送企业微信通知
                curl -X POST "$WECHAT_WEBHOOK_URL" \
                -H 'Content-Type: application/json' \
                -d "{
                  \"msgtype\": \"markdown\",
                  \"markdown\": {
                    \"content\": \"## 🎉 后端服务部署成功\\n\\n**项目**: 鉴宝管理后台后端\\n**分支**: $CODING_BUILD_REF\\n**提交**: [$CODING_BUILD_REF_NAME]($CODING_BUILD_URL)\\n**构建**: [#$CODING_BUILD_NUMBER]($CODING_BUILD_URL)\\n**环境**: $ENV_NAME\\n**API地址**: [$ENV_URL]($ENV_URL/health)\\n**文档地址**: [$ENV_URL/docs]($ENV_URL/docs)\\n\\n> 部署时间: $(date +'%Y-%m-%d %H:%M:%S')\\n> 操作者: $CODING_BUILD_TRIGGER\"
                  }
                }"
              else
                echo "📢 发送部署失败通知..."
                
                curl -X POST "$WECHAT_WEBHOOK_URL" \
                -H 'Content-Type: application/json' \
                -d "{
                  \"msgtype\": \"markdown\",
                  \"markdown\": {
                    \"content\": \"## ❌ 后端服务部署失败\\n\\n**项目**: 鉴宝管理后台后端\\n**分支**: $CODING_BUILD_REF\\n**提交**: [$CODING_BUILD_REF_NAME]($CODING_BUILD_URL)\\n**构建**: [#$CODING_BUILD_NUMBER]($CODING_BUILD_URL)\\n**失败原因**: 请查看构建日志\\n\\n> 失败时间: $(date +'%Y-%m-%d %H:%M:%S')\\n> 操作者: $CODING_BUILD_TRIGGER\\n\\n@所有人 请及时处理部署失败问题\"
                  }
                }"
              fi
            condition: always()
            env:
              WECHAT_WEBHOOK_URL: ${{ secrets.WECHAT_WEBHOOK_URL }}